{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","callback","xhr","XMLHttpRequest","open","DATABASE_URL","onload","status","responseText","error","json","JSON","send","id","fetchRestaurants","restaurants","restaurant","find","r","cuisine","results","filter","cuisine_type","neighborhood","v","i","neighborhoods","indexOf","uniqueNeighborhoods","cuisines","map","uniqueCuisines","photograph","google","maps","Marker","position","latlng","title","name","url","urlForRestaurant","animation","Animation","DROP"],"mappings":"iYAGMA,4HAcoBC,GAHxB,IAAAC,EAAA,IAAAC,eAKED,EAAIE,KAAK,MAAOJ,EAASK,cACzBH,EAAII,OAAS,WACX,GAAmB,MAAfJ,EAAIK,OAAgB,CAH1B,IAAIL,EAAUC,KAAAA,MAAAA,EAAdK,cAEAN,EAAA,KADgBF,OAEVE,CAAsB,IAAAO,EAAAA,sCAAAP,EAAAK,OACxBN,EAAMS,EAAOC,QAGNT,EAAAU,mDAMXC,EAAAZ,GAQAD,EAASc,iBAAiB,SAACL,EAAOM,GALpC,GAAAN,EAOMR,EAASQ,EAAO,UACX,CACL,IAAMO,EAAaD,EAAYE,KAAK,SAAAC,GAAA,OAAKA,EAAEL,IAAMA,IAC7CG,EACFf,EAAS,KAAMe,GAPrBf,EAAA,4BAAA,0DAMsBkB,EAAAlB,GAEjBD,EAFDc,iBAEO,SAAAL,EAAAM,GAAE,GAAAN,EACPR,EAAAA,EAAS,UACV,CATL,IAAAmB,EAAAL,EAAAM,OAAA,SAAAH,GAAA,OAAAA,EAAAI,cAAAH,IAYDlB,EAAA,KAAAmB,4DAqBoCG,EAActB,GAdjDD,EAAAA,iBAASc,SAATL,EAA0BM,GACxB,GAAAN,EACER,EAAAA,EAAA,UADF,CAIE,IAAMmB,EAAUL,EAAYM,OAAO,SAAAH,GAAA,OAAAA,EAAAK,cAAAA,IAAAtB,EAAA,KAAOqB,sEAyBDH,EAASI,EAActB,GAEpED,EAASc,iBAAiB,SAACL,EAAOM,GAChC,GAAIN,EACFR,EAASQ,EAAO,UACX,CApBT,IAAAW,EAAAL,EACSD,OAATd,IACEoB,EAAWA,EAAAC,OAAA,SAAAH,GAAA,OAAAA,EAAAI,cAAAH,KAEJ,OAFPI,IAGEH,EAAAA,EAAAC,OAAA,SAAAH,GAAA,OAAAA,EAAAK,cAAAA,KACmCtB,EAAA,KAAOsB,iDA8BtBtB,GAExBD,EAASc,iBAAiB,SAACL,EAAOM,GAChC,GAAIN,EACFR,EAASQ,EAAO,UACX,CAxBTT,IAAAA,EAASc,EAAkBL,IAAAA,SAADe,EAAQT,GAAPN,OAAOM,EAAgBU,GAAAF,eAE9CtB,EAAAyB,EAAAL,OAAA,SAAAG,EAAAC,GAAA,OAAAC,EAAAC,QAAAH,IAAAC,IACDxB,EAAM,KAAA2B,4CAKDL,GACFH,EAAAA,iBAAkBC,SAAAA,EAAON,GAAA,GAAAN,EAAAR,EAAzBQ,EAAA,UACD,CAEF,IAAAoB,EAAAd,EAAAe,IAAA,SAAAN,EAAAC,GAAA,OAAAV,EAAAU,GAAAH,eAEJS,EAAAF,EAAAR,OAAA,SAAAG,EAAAC,GAAA,OAAAI,EAAAF,QAAAH,IAAAC,IAiCKxB,EAAS,KAAM8B,+CA3BnBf,GACAhB,MAAAA,mBAAAgB,EAA2BP,iDAKqCgB,GAAtB,OAAtC,MAAsBT,EAAtBgB,WAAA,qBAAsB,QAAtBhB,EAAAgB,0DAIDhB,EAAAc,GA+CH,OAxDA,IAAAG,OAAAC,KAAAC,OAAA,CAWDC,SAAApB,EAAAqB,OAwCGC,MAAOtB,EAAWuB,KAtCtBC,IAAAxC,EAAAyC,iBAAAzB,GAwCIc,IAAKA,EACLY,UAAWT,OAAOC,KAAKS,UAAUC,4CA1JnC,MAAA","file":"dbhelper.js","sourcesContent":["/**\n * Common database helper functions.\n */\nclass DBHelper {\n\n  /**\n   * Database URL.\n   * Change this to restaurants.json file location on your server.\n   */\n  static get DATABASE_URL() {\n    const port = 1337;\n    return `http://localhost:${port}/restaurants`;\n  }\n\n  /**\n   * Fetch all restaurants.\n   */\n  static fetchRestaurants(callback) {\n    let xhr = new XMLHttpRequest();\n    xhr.open('GET', DBHelper.DATABASE_URL);\n    xhr.onload = () => {\n      if (xhr.status === 200) { // Got a success response from server!\n        const json = JSON.parse(xhr.responseText);\n        const restaurants = json;\n        callback(null, restaurants);\n      } else { // Oops!. Got an error from server.\n        const error = (`Request failed. Returned status of ${xhr.status}`);\n        callback(error, null);\n      }\n    };\n\n    xhr.send();\n  }\n\n  /**\n   * Fetch a restaurant by its ID.\n   */\n  static fetchRestaurantById(id, callback) {\n    // fetch all restaurants with proper error handling.\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        const restaurant = restaurants.find(r => r.id == id);\n        if (restaurant) { // Got the restaurant\n          callback(null, restaurant);\n        } else { // Restaurant does not exist in the database\n          callback('Restaurant does not exist', null);\n        }\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine type with proper error handling.\n   */\n  static fetchRestaurantByCuisine(cuisine, callback) {\n    // Fetch all restaurants  with proper error handling\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given cuisine type\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given neighborhood\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        let results = restaurants\n        if (cuisine != 'all') { // filter by cuisine\n          results = results.filter(r => r.cuisine_type == cuisine);\n        }\n        if (neighborhood != 'all') { // filter by neighborhood\n          results = results.filter(r => r.neighborhood == neighborhood);\n        }\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch all neighborhoods with proper error handling.\n   */\n  static fetchNeighborhoods(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all neighborhoods from all restaurants\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\n        // Remove duplicates from neighborhoods\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\n        callback(null, uniqueNeighborhoods);\n      }\n    });\n  }\n\n  /**\n   * Fetch all cuisines with proper error handling.\n   */\n  static fetchCuisines(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all cuisines from all restaurants\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\n        // Remove duplicates from cuisines\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\n        callback(null, uniqueCuisines);\n      }\n    });\n  }\n\n  /**\n   * Restaurant page URL.\n   */\n  static urlForRestaurant(restaurant) {\n    return (`./restaurant?id=${restaurant.id}`);\n  }\n\n  /**\n   * Restaurant image URL.\n   */\n  static imageUrlForRestaurant(restaurant) {\n    return restaurant.photograph == null ? '/img/missing-image' : (`/img/${restaurant.photograph}`);\n  }\n\n  /**\n   * Map marker for a restaurant.\n   */\n  static mapMarkerForRestaurant(restaurant, map) {\n    const marker = new google.maps.Marker({\n      position: restaurant.latlng,\n      title: restaurant.name,\n      url: DBHelper.urlForRestaurant(restaurant),\n      map: map,\n      animation: google.maps.Animation.DROP}\n    );\n    return marker;\n  }\n\n}\n"]}